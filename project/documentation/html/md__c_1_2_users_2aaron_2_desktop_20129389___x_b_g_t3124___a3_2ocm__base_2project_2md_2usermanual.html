<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KanataGameEngine: User Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ka1.jpg"/></td>
  <td id="projectalign">
   <div id="projectname">KanataGameEngine
   </div>
   <div id="projectbrief">Game Engine Architecture and Design</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__c_1_2_users_2aaron_2_desktop_20129389___x_b_g_t3124___a3_2ocm__base_2project_2md_2usermanual.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">User Manual</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md0"></a>
Introduction</h1>
<p>Welcome to the user manual for Kanata Engine! This manual will guide you through the process of using the engine to create scenes, custom components, and assemble them into a complete game.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Table of Contents</h1>
<ol type="1">
<li><a class="el" href="md__c_1_2_users_2aaron_2_desktop_20129389___x_b_g_t3124___a3_2ocm__base_2project_2md_2usermanual.html#introduction">Introduction</a></li>
<li><a class="el" href="md__c_1_2_users_2aaron_2_desktop_20129389___x_b_g_t3124___a3_2ocm__base_2project_2md_2usermanual.html#creating-scenes">Creating Scenes</a></li>
<li><a class="el" href="md__c_1_2_users_2aaron_2_desktop_20129389___x_b_g_t3124___a3_2ocm__base_2project_2md_2usermanual.html#custom-components">Custom Components</a></li>
<li><a class="el" href="md__c_1_2_users_2aaron_2_desktop_20129389___x_b_g_t3124___a3_2ocm__base_2project_2md_2usermanual.html#assembling-elements">Assembling Game Elements</a></li>
<li><a class="el" href="md__c_1_2_users_2aaron_2_desktop_20129389___x_b_g_t3124___a3_2ocm__base_2project_2md_2usermanual.html#core-game-engine-components">Core Game Engine Components</a><ul>
<li><a class="el" href="md__c_1_2_users_2aaron_2_desktop_20129389___x_b_g_t3124___a3_2ocm__base_2project_2md_2usermanual.html#transformcomponent">TransformComponent</a></li>
<li><a class="el" href="md__c_1_2_users_2aaron_2_desktop_20129389___x_b_g_t3124___a3_2ocm__base_2project_2md_2usermanual.html#spriterenderer">SpriteRenderer</a></li>
<li><a class="el" href="md__c_1_2_users_2aaron_2_desktop_20129389___x_b_g_t3124___a3_2ocm__base_2project_2md_2usermanual.html#progressbar">ProgressBar</a></li>
<li><a class="el" href="md__c_1_2_users_2aaron_2_desktop_20129389___x_b_g_t3124___a3_2ocm__base_2project_2md_2usermanual.html#animatedspriterenderer">AnimatedSpriteRenderer</a></li>
<li><a class="el" href="md__c_1_2_users_2aaron_2_desktop_20129389___x_b_g_t3124___a3_2ocm__base_2project_2md_2usermanual.html#resource-management">Resource Management</a></li>
</ul>
</li>
<li><a class="el" href="md__c_1_2_users_2aaron_2_desktop_20129389___x_b_g_t3124___a3_2ocm__base_2project_2md_2usermanual.html#conclusion">Conclusion</a></li>
</ol>
<h1><a class="anchor" id="introduction"></a>
Introduction</h1>
<p>Kanata Engine is a useful game development framework that provides tools and features to make your game development process smoother and more efficient. Whether you're a seasoned developer or just getting started, this manual will help you harness the capabilities of the engine.</p>
<h1><a class="anchor" id="creating-scenes"></a>
Creating Scenes</h1>
<p>Scenes are the building blocks of your game. They represent different levels, menus, or gameplay segments. Here's how you can create scenes using Kanata Engine:</p>
<ol type="1">
<li>Define a New Scene Class</li>
<li>Add the Scene to the Scene State Machine</li>
<li>Implement Scene-Specific Logic</li>
<li>Transitions Between Scenes</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// 1. To create a new scene, you&#39;ll need to define a new class that inherits from the BaseScene class. This class will encapsulate the logic, assets, and elements specific to the scene you&#39;re creating.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Example: MyScene.h</span></div>
<div class="line"><span class="preprocessor">    #include &quot;BaseScene.h&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="keyword">class </span>MyScene : <span class="keyword">public</span> BaseScene {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        MyScene() {} <span class="comment">// Constructor</span></div>
<div class="line"> </div>
<div class="line">        std::string getName()<span class="keyword"> const override </span>{</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;MyScene&quot;</span>; <span class="comment">// Return the name of the scene</span></div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">        <span class="keywordtype">void</span> initialize()<span class="keyword"> override </span>{</div>
<div class="line">            <span class="comment">// Initialize assets, game objects, and other scene-specific elements here</span></div>
<div class="line">        }</div>
<div class="line">    };</div>
</div><!-- fragment --><div class="fragment"></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// 2. Use the addScene() method from the SceneStateMachine class to add the newly created scene class. This ensures that your scene is properly managed by the engine.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Adding the scene to SceneStateMachine</span></div>
<div class="line">    MyScene* myScene = SceneStateMachine::addScene&lt;MyScene&gt;();</div>
</div><!-- fragment --><div class="fragment"></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// 3. Inside your scene class, implement the necessary functions such as initialize(), on_activate(), on_deactivate(), on_update(), and on_render(). These functions allow you to define how the scene behaves during different stages of its lifecycle.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// MyScene.cpp</span></div>
<div class="line">    <span class="keywordtype">void</span> MyScene::initialize() {</div>
<div class="line">        <span class="comment">// Initialize assets, game objects, and other scene-specific elements here</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> MyScene::on_activate() {</div>
<div class="line">        <span class="comment">// Activate logic specific to this scene</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> MyScene::on_deactivate() {</div>
<div class="line">        <span class="comment">// Deactivate logic specific to this scene</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... Other scene-specific functions</span></div>
</div><!-- fragment --><div class="fragment"></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// 4. You can transition between scenes by using the loadScene() method provided by the SceneStateMachine class. This allows you to switch from one scene to another based on specific events or conditions.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Transitioning to MyScene by name</span></div>
<div class="line">    SceneStateMachine::loadScene(<span class="stringliteral">&quot;MyScene&quot;</span>);</div>
</div><!-- fragment --><p>By following these steps, you can create, manage, and transition between different scenes in your game using the BaseScene and SceneStateMachine classes provided by the Kanata Engine.</p>
<h1><a class="anchor" id="custom-components"></a>
Custom Components</h1>
<p>Custom components allow you to add unique behaviors and functionality to your game objects. Follow these steps to create and add custom components:</p>
<ul>
<li>Define a New Component Class: Create a new class that inherits from the BaseComponent class. This will serve as the foundation for your custom component. Make sure to include the necessary headers and forward declarations.</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;BaseComponent.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span> <span class="comment">// Include other headers if needed</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespace_kanata_engine.html">KanataEngine</a> {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">class </span>CustomComponent : <span class="keyword">public</span> BaseComponent {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        CustomComponent(<a class="code hl_class" href="class_game_object.html">GameObject</a>* go);</div>
<div class="line">        ~CustomComponent();</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> awake();</div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> start();</div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> update(<span class="keywordtype">float</span> deltaTime);</div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> render();</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="aclass_game_object_html"><div class="ttname"><a href="class_game_object.html">GameObject</a></div><div class="ttdoc">Represents a game object that can hold components and manage their lifecycle.</div><div class="ttdef"><b>Definition</b> GameObject.h:21</div></div>
<div class="ttc" id="anamespace_kanata_engine_html"><div class="ttname"><a href="namespace_kanata_engine.html">KanataEngine</a></div><div class="ttdef"><b>Definition</b> AnimatedSpriteRendererComponent.cpp:3</div></div>
</div><!-- fragment --><div class="fragment"></div><!-- fragment --><ul>
<li>Implement Constructor and Destructor: Implement the constructor and destructor for your custom component. Pass the GameObject* parameter to the base constructor.</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;CustomComponent.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespace_kanata_engine.html">KanataEngine</a> {</div>
<div class="line"> </div>
<div class="line">    CustomComponent::CustomComponent(<a class="code hl_class" href="class_game_object.html">GameObject</a>* go) : BaseComponent(go) {</div>
<div class="line">        <span class="comment">// Custom initialization if needed</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    CustomComponent::~CustomComponent() {</div>
<div class="line">        <span class="comment">// Custom cleanup if needed</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Implement the rest of the component&#39;s methods...</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"></div><!-- fragment --><ul>
<li>Define Custom Behavior: Inside your custom component class, implement the methods (awake(), start(), update(), render(), etc.) to define the behavior of your component. Customize these methods according to the functionality your component should provide.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CustomComponent::awake() {</div>
<div class="line">    <span class="comment">// Initialize resources or perform actions upon awakening</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> CustomComponent::start() {</div>
<div class="line">    <span class="comment">// Perform setup or initialization tasks when the component starts</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> CustomComponent::update(<span class="keywordtype">float</span> deltaTime) {</div>
<div class="line">    <span class="comment">// Implement component-specific update logic</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> CustomComponent::render() {</div>
<div class="line">    <span class="comment">// Implement rendering logic if necessary</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"></div><!-- fragment --><ul>
<li>Add Custom Component to <a class="el" href="class_game_object.html" title="Represents a game object that can hold components and manage their lifecycle.">GameObject</a>: When creating a <a class="el" href="class_game_object.html" title="Represents a game object that can hold components and manage their lifecycle.">GameObject</a>, you can attach your custom component to it. For example, if you want to add CustomComponent to a <a class="el" href="class_game_object.html" title="Represents a game object that can hold components and manage their lifecycle.">GameObject</a> named myObject:</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Create a GameObject</span></div>
<div class="line"><a class="code hl_class" href="class_game_object.html">GameObject</a>* myObject = <span class="keyword">new</span> <a class="code hl_class" href="class_game_object.html">GameObject</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Attach CustomComponent to the GameObject</span></div>
<div class="line">CustomComponent* customComponent = <span class="keyword">new</span> CustomComponent(myObject);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Optionally, add more components if needed</span></div>
<div class="line"><span class="comment">// myObject-&gt;addComponent(...);</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add the GameObject to the scene or perform other actions</span></div>
</div><!-- fragment --><div class="fragment"></div><!-- fragment --><ul>
<li>Integrate Custom Component in the Game: After creating and attaching your custom component to a <a class="el" href="class_game_object.html" title="Represents a game object that can hold components and manage their lifecycle.">GameObject</a>, integrate it into your game logic. You can manipulate and interact with the component through the <a class="el" href="class_game_object.html" title="Represents a game object that can hold components and manage their lifecycle.">GameObject</a> it's attached to. By following these steps, you can create and integrate custom components into <a class="el" href="namespace_kanata_engine.html">KanataEngine</a> to extend the functionality and behavior of your game objects.</li>
</ul>
<hr  />
<h1><a class="anchor" id="assembling-elements"></a>
Assembling Game Elements</h1>
<p>Now that you have scenes and custom components, it's time to bring everything together to create your game. Follow these steps:</p>
<ol type="1">
<li>Create and design multiple scenes to represent different parts of your game.</li>
<li>Populate scenes with game objects and customize their properties using the "Inspector" panel.</li>
<li>Attach appropriate components to game objects to give them behaviors.</li>
<li>Use scripting to implement interactions, animations, and game logic.</li>
<li>Define the flow of your game by transitioning between scenes using triggers or scripts.</li>
</ol>
<p>Remember, Kanata Engine offers a range of features beyond what's covered in this manual. Explore the documentation and experiment with different components to unleash the full potential of your game development.</p>
<hr  />
<h1><a class="anchor" id="core-game-engine-components"></a>
Core Game Engine Components</h1>
<h2><a class="anchor" id="transformcomponent"></a>
TransformComponent</h2>
<p>The Transform Component, an essential part of the OCM system, handles transformations within the game. Key features of the Transform Component include:</p>
<ol type="1">
<li><a class="el" href="class_game_object.html" title="Represents a game object that can hold components and manage their lifecycle.">GameObject</a> Creation: Create a <a class="el" href="class_game_object.html" title="Represents a game object that can hold components and manage their lifecycle.">GameObject</a> that requires spatial properties to be managed, such as position and rotation.</li>
<li>Component Attachment: Attach a TransformComponent to the <a class="el" href="class_game_object.html" title="Represents a game object that can hold components and manage their lifecycle.">GameObject</a>. This is typically done during the <a class="el" href="class_game_object.html" title="Represents a game object that can hold components and manage their lifecycle.">GameObject</a>'s initialization.</li>
<li>Accessing and Modifying: Use the provided accessor methods (getX(), getY(), getRotation()) to retrieve the current position and rotation values of the <a class="el" href="class_game_object.html" title="Represents a game object that can hold components and manage their lifecycle.">GameObject</a>.</li>
<li>Position and Rotation Adjustments: Utilize the mutator methods (setX(), setY(), setRotation()) to set or change the position and rotation of the <a class="el" href="class_game_object.html" title="Represents a game object that can hold components and manage their lifecycle.">GameObject</a> as needed.</li>
<li>Lifecycle Integration: The TransformComponent integrates into the <a class="el" href="class_game_object.html" title="Represents a game object that can hold components and manage their lifecycle.">GameObject</a>'s lifecycle by providing empty implementations of lifecycle hooks (awake(), start(), update(), and render()). Developers can extend these methods if specific behavior is required at different stages.</li>
<li>Render Transformations: During the rendering phase, apply the <a class="el" href="class_game_object.html" title="Represents a game object that can hold components and manage their lifecycle.">GameObject</a>'s position and rotation by utilizing the retrieved values from the TransformComponent. This ensures that the <a class="el" href="class_game_object.html" title="Represents a game object that can hold components and manage their lifecycle.">GameObject</a> is displayed correctly within the 2D space.</li>
</ol>
<p>Functionalities of Transform Component include:</p><ul>
<li>Position (XY), rotation (Z), and scaling (XY) properties.</li>
<li>Accessible via <code>setXXX()</code> and <code>getXXX()</code> methods.</li>
<li>Automatically added to GameObjects upon creation, providing fundamental transformation capabilities.</li>
</ul>
<h2><a class="anchor" id="spriterenderer"></a>
SpriteRenderer</h2>
<p>The SpriteRenderer component provides the following features: Utilizes transform values from the Transform component.</p>
<ol type="1">
<li>Color tinting and opacity control. The default is white color with opacity of 1.0.<ul>
<li><code>setColour(r, g, b)</code></li>
<li><code>setColour(Vec3)</code></li>
<li><code>setOpacity(a)</code></li>
</ul>
</li>
<li>Custom sprite size setting. The default is the loaded texture size.<ul>
<li><code>setSize(w, h)</code></li>
<li><code>setSize(Vec2)</code></li>
</ul>
</li>
<li>Sprite pivot adjustment. The default is (x:0.5, y:0.5).<ul>
<li><code>setPivot(x, y)</code></li>
<li><code>setPivot(Vec2)</code></li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="animatedspriterenderer"></a>
AnimatedSpriteRenderer</h2>
<p>The AnimatedSpriteRenderer component is a specialization of the SpriteRendererComponent that allows for displaying animations by switching between different texture frames over time. It's used to render animated sprites in a game.</p>
<ol type="1">
<li>AnimatedSpriteRenderer(GameObject* go, float initialX, float initialY, const std::string&amp; texturePaths): Constructor that takes a <a class="el" href="class_game_object.html" title="Represents a game object that can hold components and manage their lifecycle.">GameObject</a>, initial position (initialX and initialY), and a path to the initial texture. It initializes various properties such as animation speed, frame index, and frame duration.</li>
<li>addAnimationFrame(const std::string&amp; texturePath): This function allows you to add additional frames to the animation. It takes the path to a texture and adds it to the list of animation frames.</li>
<li>playAnimation(float deltaTime): This function advances the animation by switching to the next frame based on the elapsed time (deltaTime). It calculates the frame index to switch to and updates the frame timer accordingly. The animation speed can be adjusted using setAnimationSpeed(float speed).</li>
<li>setAnimationSpeed(float speed): This function allows you to set the speed of the animation playback.</li>
<li>switchToFrame(int frameIndex): This function switches the current displayed texture to the one specified by the given frameIndex.</li>
<li>~AnimatedSpriteRenderer(): Destructor that cleans up the allocated animation frames' textures and clears the animation frames vector.</li>
</ol>
<h2><a class="anchor" id="resource-management"></a>
Resource Management</h2>
<p>Resource allocation is managed through the ResourceAllocator class template. This allows different kinds of resource allocators to exist without needing explicit code creation. This allows Textures and Sprites be requested and allocated before they are displayed or called within the game screen.</p>
<ol type="1">
<li>Texture Creation: Create textures using the Texture::createTexture() method by passing the file path of the texture. This method loads the texture and returns a Texture object.</li>
<li>Binding Textures: To use a texture in rendering, call the bind() method on a Texture object. This binds the OpenGL texture for rendering.</li>
<li>Requesting Textures: To request a texture, call the TextureAllocator::requestTexture() method, passing the texture's file path. This checks if the texture has been loaded before and reuses it if found.</li>
<li>Deleting Textures: When a texture is no longer needed, call TextureAllocator::deleteTexture() and pass the Texture object to be deleted. The allocator manages the reference count and deletes the texture when its reference count reaches zero.</li>
<li>Reference Counting: The Texture class maintains a reference count. Every time a texture is requested or reused, its reference count increases. When a texture is deleted, its reference count decreases. Textures with a reference count of zero are safe to be deleted.</li>
<li>Resource Management: The TextureAllocator maintains an internal map (textureMap) that stores loaded textures. This map allows for quick retrieval of existing textures and efficient management of memory.</li>
</ol>
<p>By utilizing the ResourceAllocator, you can streamline texture loading and management, preventing duplicate loading and ensuring proper deallocation of resources, leading to more efficient memory usage in your game or application.</p>
<h2><a class="anchor" id="progressbar"></a>
ProgressBar</h2>
<p>The ProgressBarComponent class offers functionality for creating and managing progress bars within the Kanata Engine environment: Uses OpenGL to draw two rectangles: one for the background of the progress bar and another to indicate the current progress level. The position, size, and color of these rectangles are determined by the initialPosition, barSize, and barWidth values, respectively.</p>
<ol type="1">
<li>Creates an instance of ProgressBarComponent and associates it with the specified <a class="el" href="class_game_object.html" title="Represents a game object that can hold components and manage their lifecycle.">GameObject</a>. There is no default value for a pointer parameter go.<ul>
<li><code>ProgressBarComponent(GameObject* go)</code></li>
<li><code>~ProgressBarComponent()</code></li>
</ul>
</li>
<li>Sets the value of the progress bar. The default value for them are all set to 0.0f.<ul>
<li><code>setInitialPosition(Vec2 pos)</code></li>
<li><code>setProgress(float value)</code></li>
<li><code>setTargetProgress(float value)</code></li>
</ul>
</li>
<li>Adjusts the size of the progress bar. The default value for it are also set to 0.0f;<ul>
<li><code>setBarWidth(float width)</code><ul>
<li><code>setSize(Vec2 valSize)</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h1><a class="anchor" id="conclusion"></a>
Conclusion</h1>
<p>Thank you for choosing Kanata Engine! If you have any questions or need further assistance, refer to the full documentation or reach out to our support team.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md5"></a>
Game Object &amp; Component Model (OCM) System</h1>
<p>The Game Object &amp; Component Model (OCM) System is an architectural design pattern employed by Kanata Engine. This system aims to enhance flexibility and maintainability by separating game objects from their behaviors (components). Instead of relying on complex inheritance hierarchies, OCM encourages a composition-based approach. Game objects are constructed by combining various components, each contributing specific functionality. This modular approach allows for greater modularity, extensibility, and ease of collaboration among developers.</p>
<p>The OCM system brings multiple advantages to game development, including:</p>
<ul>
<li><b>Modularity</b>: Components can be shared among different objects, reducing redundancy and promoting modular design.</li>
<li><b>Flexibility</b>: Objects gain functionalities through the combination of components, eliminating the need for complex class hierarchies.</li>
<li><b>Extensibility</b>: Introducing new functionality involves creating and attaching components, streamlining the development process.</li>
<li><b>Collaboration</b>: Developers can work on distinct components concurrently, ensuring smoother collaboration within teams.</li>
<li><b>Maintainability</b>: Isolating changes to specific components simplifies maintenance without affecting the overall object structure.</li>
</ul>
<p>Kanata Engine's OCM System revolutionizes game development by offering a versatile and efficient methodology for building complex game behaviors.</p>
<hr  />
 </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
